//6147问题
//【题目描述】
//假设你有一个各位数字互不相同的四位数，把所有数字从大到小排序后得到a，从小到大排序后得到b，
//然后用a - b替换原来的数，并且继续操作。
//有趣的是这样操作了几次后会得到四位数6174，而对6174进行处理，为7641 - 1467 = 6174，回到了它自己。
//输入一个n位数（不一定是四位数），输出操作序列，直到第一次出现循环。输入保证在循环之前最多只会产生1000个整数。
//注意：若输入0则无输出
//【输入格式】
//一行一个整数
//【输出格式】
//一行输出操作序列(包括一开始的数)
//（注：序列中的每个数通过一个空格隔开。）
//【输入样例1】
//1234
//【输出样例1】
//1234 3087 8352 6174 6174
//【输入样例2】
//1234567
//【输出样例2】
//1234567 6419754 8319762 8639532 7529643 7419753 8429652 7619733 8439552 7509843 9529641 8719722 8649432 7519743 8429652
#include<iostream>
#include<cmath>
 using namespace std;
int nu(int x)//计算x的位数 （x为整数）
{
	return int(log10(x)) + 1;
}
void swap(int & a1, int & a2)
{
	int t = a2;
	a2 = a1;
	a1 = t;
}
int f(int x)//返回输入数字排序后的最大值减去最小值的值
{
	int a[1000];
	int max = 0, min = 0;
	static int N = nu(x);

	for (int i = 1; i <= N; i++)
	{
		a[i] = x % 10;
		x /= 10;
	}//取各个位数字 
	//冒泡排序bubbleSort
	for (int n = 1; n <= N; n++)//n < N 的运行结果也一样
	{
		for (int i = 1; i <= N - n ; i++)
		{
			if (a[n] < a[n + i])
			{
				swap(a[n], a[n + i]);
			}
		}
	}

	for (int o = 1; o <= N; o++)
	{
		max = 10 * max + a[o];
	}

	for (int r = N; r >= 1; r--)
	{
		min = 10 * min + a[r];
	}
	return (max - min);
}
int main()
{
	int b[1000];
	int t, i = 1;
	cin >> t;
	if (!t)
	{
		return 0;//如果输入的是0，就没有输出
	}
	cout << t << " ";
	while (1)
	{
		b[i] = f(t);
		cout << b[i] << " ";
		for (int n = 1; n < i; n++)
		{
			if (b[i] == b[n])
			{
				return 0;
			}
		}
		t = b[i];
		i++;
	}
}